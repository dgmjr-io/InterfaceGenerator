//
// InterfaceGenerator.cs
//
//   Created: 2022-11-11-03:54:47
//   Modified: 2022-11-12-11:16:54
//
//   Author: David G. Mooore, Jr. <david@dgmjr.io>
//
//   Copyright Â© 2022-2023 David G. Mooore, Jr., All Rights Reserved
//      License: MIT (https://opensource.org/licenses/MIT)
//


namespace Dgmjr.InterfaceGenerator;

using System;

// using Dgmjr.ion.Extensions;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using static System.String;

[Generator]
public partial class EnumerationClassGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the generator. This is called during generation and can be used to register source code that will be generated by the generator.
    /// </summary>
    /// <param name="context">Provides information about the compilation and environment that is passed to the generator</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var interfaces = context.SyntaxProvider.ForAttributeWithMetadataName(GenerateInterfaceAttributeName,
            (token, _) => token is InterfaceDeclarationSyntax interfaceDeclarationSyntax && interfaceDeclarationSyntax.AttributeLists.Any(al => al.Attributes.Any(a => a.Name.ToString() == GenerateInterfaceAttributeName)),
        (context, _) =>
            (context.Attributes.FirstOrDefault(a => a.AttributeClass?.Name == GenerateInterfaceAttributeName), context.TargetSymbol as INamedTypeSymbol, context.SemanticModel)
        ).Collect();

        var compilation = context.CompilationProvider;

        context.RegisterSourceOutput(interfaces, Generate);

        context.RegisterPostInitializationOutput((ctx) => ctx.AddSource($"{GenerateInterfaceAttributeName}.g.cs", GenerateInterfaceAtributeDeclaration));
    }

    /// <summary>
    /// Generates code for an attribute. This is the entry point for the generation of code for attributes that are derived from a type.
    /// </summary>
    /// <param name="context">The context in which to generate the code.</param>
    /// <param name="values">The values to generate for the attribute. This is an array of tuples where the first element is the attribute data the second element is the interface and the</param>
    protected static void Generate(SourceProductionContext context, ImmutableArray<(AttributeData, INamedTypeSymbol, SemanticModel)> values)
    {
        context.AddSource($"AttributeCount.g.cs", $"/* {values.Length} */");
        foreach (var (attributeData, interfaceSymbol, semanticModel) in values)
        {
            var interfaceName = interfaceSymbol.Name;
            var interfaceNamespace = interfaceSymbol.ContainingNamespace.ToDisplayString();
            var classToGenerateTheInterfaceFor = attributeData.ConstructorArguments.First().Value as INamedTypeSymbol;
            context.AddSource(interfaceName + ".g.cs",
            InterfaceDeclarationTemplate.Render(new InterfaceGeneratorModel(interfaceNamespace, interfaceName,
                Join(System.Environment.NewLine,
                    classToGenerateTheInterfaceFor
                    .GetMembers()
                    .Where(member => member.Kind is SymbolKind.Property)
                    .OfType<IPropertySymbol>()
                    .Where(p => p.DeclaredAccessibility == Accessibility.Public)
                    .Select(p =>
                        PropertyDeclarationTemplate.Render(new PropertyDeclarationModel("public", p.Type.ToDisplayString(), p.Name, p.GetMethod != null, p.SetMethod != null)))) +
                Join(System.Environment.NewLine,
                    classToGenerateTheInterfaceFor
                    .GetMembers()
                    .Where(member => member.Kind is SymbolKind.Method)
                    .OfType<IMethodSymbol>()
                    .Where(m => m.DeclaredAccessibility == Accessibility.Public && m.CanBeReferencedByName)
                    .Select(m =>
                        MethodDeclarationTemplate.Render(new MethodDeclarationModel(m.ReturnType.ToDisplayString(),
                            m.Name + (m.IsGenericMethod ? $"<{Join(", ", m.TypeParameters.Select(tp => tp.Name))}>" : ""),
                            Join(", ", m.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}")),
                            m.IsGenericMethod ? $"{Join(System.Environment.NewLine,
                                m.TypeParameters.Select(tp =>
                                    tp.HasReferenceTypeConstraint || tp.HasValueTypeConstraint || tp.HasConstructorConstraint || tp.ConstraintTypes.Any() ?
                                    "where " + tp.Name + " : " +
                                    (tp.HasReferenceTypeConstraint ? "class" : "") +
                                    (tp.HasValueTypeConstraint ? "struct" : "") +
                                    Join(", ", tp.ConstraintTypes.Select(ct => ct.ToDisplayString())) +
                                    (tp.HasConstructorConstraint ? "new()" : "").Trim() : ""))}" : "")))))));
        }
    }
}


//     public virtual void Generate(SourceProductionContext context, (Compilation Compilation, (AnalyzerConfigOptionsProvider AnalyzerConfigOptions, ImmutableArray<(InterfaceDeclarationSyntax, SemanticModel, ImmutableArray<AttributeData>)> Values) Values) values)
//     {
//         try
//         {
//             var (compilation, (analyzerConfigOptions, Values)) = values;
//             var interfaceAtributeDeclaration = GenerateInterfaceAtributeDeclaration;
//             var header = Header;
//             context.AddSource(GenerateInterfaceAttributeName + ".g.cs", interfaceAtributeDeclaration);
//             foreach(var (interfaceDeclaration, semanticModel, attributeData) in Values)
//             {
//                 var interfaceName = interfaceDeclaration.Identifier.Text;
//                 var interfaceNamespace = interfaceDeclaration.GetNamespace();
//                 var classToGenerateTheInterfaceFor = (Type)attributeData.First().ConstructorArguments.First().Value!;
//                 context.AddSource(interfaceName + "g.cs", $@"/* {header}
//     {classToGenerateTheInterfaceFor.Namespace}.{classToGenerateTheInterfaceFor.Name}
//     */");
//         }}
//         catch(Exception ex)
//         {
//             context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("INTERFACEGENERATOR", "Strongly Typed Resource Generator", ex.Message, "INTERFACEGENERATOR", DiagnosticSeverity.Error, true), Location.Create("StronglyTypesEmbeddedResourceGenerator.cs", new TextSpan(0, 0), new LinePositionSpan(new LinePosition(0, 0), new LinePosition(0, 0)))));
//             context.AddSource("Error.g.cs", $@"/* {ex.Source}: {ex.Message}:
// {ex.StackTrace} */");
//         }
//     }
