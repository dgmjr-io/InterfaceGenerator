/* 
 * DecomposerConstants.cs
 * 
 *   Created: 2023-04-13-12:23:57
 *   Modified: 2023-04-13-12:23:57
 * 
 *   Author: David G. Moore, Jr. <david@dgmjr.io>
 *   
 *   Copyright Â© 2022 - 2023 David G. Moore, Jr., All Rights Reserved
 *      License: MIT (https://opensource.org/licenses/MIT)
 */

namespace Dgmjr.InterfaceGenerator.Decomposer
{
    public static class Constants
    {

        public const string ThisAssemblyName = ThisAssembly.Project.AssemblyName;
        public const string ThisAssemblyVersion = ThisAssembly.Info.Version; 
        public const string DecomposedInterfaceHeader =
        $$$"""
        //----------------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by {{{ThisAssemblyName}}}, version {{{ThisAssemblyVersion}}}
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //----------------------------------------------------------------------------------------
        
        """;

        public const string GeneratedCodeAttribue =
        $$$"""
        [System.Runtime.CompilerServices.CompilerGenerated]
        [System.CodeDom.Compiler.GeneratedCode(\"{{{ThisAssemblyName}}}\", \"{{{ThisAssemblyVersion}}}\")]";
        """;

        public const string DecomposableAttributeName = "DecomposableAttribute";
        public const string DecomposableAttributeNamespace = "Dgmjr.InterfaceGenerator.Decomposer";
        public const string DecomposableAttributeFullName = DecomposableAttributeNamespace + "." + DecomposableAttributeName;

        public const string IDecomposedInterfaceDeclaration = 
        DecomposedInterfaceHeader +
        GeneratedCodeAttribue + 
        $$$"""public interface IDecomposed<{{ decomposed_from }}> { }""";

        public static readonly Scriban.Template IDecomposedInterfaceDeclarationTemplate = Scriban.Template.Parse(IDecomposedInterfaceDeclaration);

        public const string IDecomposedMarkerInterfaceDeclaration =
        DecomposedInterfaceHeader +
        GeneratedCodeAttribue + 
        $$$"""
        public interface I{{ decomposed_from }}{{ memeber_name }}
        {
        """;
        
        public static readonly Scriban.Template IDecomposedMarkerInterfaceDeclarationTemplate = Scriban.Template.Parse(IDecomposedMarkerInterfaceDeclaration);

        public const string DecomposedPropertyDeclaration =
        
        GeneratedCodeAttribue + 
        """
            {{ property_type }} {{ property_name }} { {{ if is_gettable }} get; {{ end }} {{ if is_settable }} set; {{ end }}  }
        """;

        public static readonly Scriban.Template DecomposedPropertyDeclarationTemplate = Scriban.Template.Parse(DecomposedPropertyDeclaration);

        public const string DecomposedMethodDeclaration =
    
        GeneratedCodeAttribue +  
        """
            {{ return_type }} {{ method_name }} ({{ for parameter in parameters }}{{ parameter.type }} {{ parameter.name }}{{ if not loop.last }}, {{ endif }}{{ endfor }})
            {{ if has_generic_type_constraints }}
            {{ for generic_type_constraint in generic_type_constraints }} where {{ generic_type_constraint.name }} : {{ type_constraint.constraint }}
            {{ endfor }}
            {{ endif }}
        """;


        public const string DecomposableAttributeDeclaration =
        DecomposedInterfaceHeader +
        """
        [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct | global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method)]
        public sealed class DecomposeAttribute : global::System.Attribute 
        {
            public DecomposeAttribute() { }
            public DecomposeAttribute(global::System.Type type) { }
        }
        """;



        public static readonly Scriban.Template DecomposedMethodDeclarationTemplate = Scriban.Template.Parse(DecomposedMethodDeclaration);


        public const string IComposedClassDeclaration = 
        """
        public partial class {{ class_name }} : {{ for type_member_tuple in decomposed_from }} IDecomposed<{{} decomposed_from.type }}>
        {
            {{ for type_member_tuple in decomposed_from }}
            {{ if type_member_tuple.member.is_property }}
            public {{ type_member_tuple.member.type }} {{ type_member_tuple.member.name }} {{ get; }}
            {{ elif type_member_tuple.member.is_method }}
            public {{ decomposed_from.type }} {{} decomposed_from.member }} {{ get; }}
            {{ endfor }}


            public { class_name }({ decomposed_from } decomposed)
            {
                { decomposed_from } = decomposed;
            }

            public { decomposed_from } { decomposed_from } {{ get; }}
        }
        """;
    }
}
