/*
 * InterfaceGenerator.cs
 *
 *   Created: 2022-11-11-03:54:47
 *   Modified: 2022-11-12-11:16:54
 *
 *   Author: David G. Moore, Jr. <david@dgmjr.io>
 *
 *   Copyright Â© 2022-2023 David G. Moore, Jr., All Rights Reserved
 *      License: MIT (https://opensource.org/licenses/MIT)
 */
namespace Dgmjr.InterfaceGenerator;

using System.Collections.Immutable;
using System.Composition.Convention;
using System.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static System.String;
using static Environment;

[Generator]
public partial class InterfaceGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the generator. This is called during generation and can be used to register source code that will be generated by the generator.
    /// </summary>
    /// <param name="context">Provides information about the compilation and environment that is passed to the generator</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(
            ctx => ctx.AddSource(AttributeClass + _g + _cs, GenerateInterfaceAtributeDeclaration)
        );

        var interfaces = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                GenerateInterfaceAttributeName,
                (token, _) =>
                    token
                        is InterfaceDeclarationSyntax
                            or ClassDeclarationSyntax
                            or StructDeclarationSyntax,
                (context, _) =>
                    (
                        context.Attributes.FirstOrDefault(a => a.AttributeClass?.Name != null),
                        context.TargetSymbol as INamedTypeSymbol,
                        context.SemanticModel
                    )
            )
            .Collect();

        context.RegisterSourceOutput(interfaces, Generate);
    }

    /// <summary>
    /// Generates code for an attribute. This is the entry point for the generation of code for attributes that are derived from a type.
    /// </summary>
    /// <param name="context">The context in which to generate the code.</param>
    /// <param name="values">The values to generate for the attribute. This is an array of tuples where the first element is the attribute data the second element is the interface and the</param>
    protected static void Generate(
        SourceProductionContext context,
        ImmutableArray<(AttributeData?, INamedTypeSymbol?, SemanticModel)> values
    )
    {
        context.AddSource("AttributeCount.g.cs", $"/* {values.Length} */");
        foreach ((var attributeData, var targetSymbol, var semanticModel) in values)
        {
            var interfaceName = attributeData.ConstructorArguments.Skip(1).FirstOrDefault().Value
                is string @in
                ? @in
                : default;
            interfaceName ??=
                targetSymbol.TypeKind == TypeKind.Interface
                    ? targetSymbol.Name
                    : "I"
                        + targetSymbol.Name
                        + (
                            targetSymbol.IsGenericType
                                ? Join(", ", targetSymbol.TypeParameters.Select(tp => tp.Name))
                                : ""
                        );
            var interfaceNamespace = attributeData.ConstructorArguments
                .Skip(2)
                .FirstOrDefault()
                .Value
                is string @is
                ? @is
                : default;
            interfaceNamespace ??= targetSymbol.ContainingNamespace.ToDisplayString();
            var classToGenerateTheInterfaceFor =
                attributeData.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol
                ?? targetSymbol;
            context.AddSource(
                interfaceName + _g + _cs,
                Regex.Replace(
                    Regex.Replace(
                        Regex.Replace(
                            InterfaceDeclarationTemplate
                                .Render(
                                    new InterfaceGeneratorModel(
                                        interfaceNamespace,
                                        interfaceName,
                                        Join(
                                            NewLine,
                                            classToGenerateTheInterfaceFor
                                                .GetMembers()
                                                .Where(member => member.Kind is SymbolKind.Property)
                                                .OfType<IPropertySymbol>()
                                                .Where(
                                                    p =>
                                                        p.DeclaredAccessibility
                                                            == Accessibility.Public
                                                        && !p.IsStatic
                                                )
                                                .Select(
                                                    p =>
                                                        p.ToDisplayString(
                                                            Constants.SymbolDisplayFormat
                                                        )
                                                )
                                        )
                                            + NewLine
                                            + Join(
                                                NewLine,
                                                classToGenerateTheInterfaceFor
                                                    .GetMembers()
                                                    .Where(
                                                        member => member.Kind is SymbolKind.Method
                                                    )
                                                    .OfType<IMethodSymbol>()
                                                    .Where(
                                                        m =>
                                                            m.DeclaredAccessibility
                                                                == Accessibility.Public
                                                            && m.CanBeReferencedByName
                                                            && !m.IsStatic
                                                    )
                                                    .Select(
                                                        m =>
                                                            m.IsOverride
                                                                ? ""
                                                                : (
                                                                    m.ToDisplayString(
                                                                            Constants.SymbolDisplayFormat
                                                                        )
                                                                        .Replace("override", "")
                                                                    + ";"
                                                                )
                                                    )
                                                    .Where(m => m.IndexOf("*") < 0)
                                            ),
                                        targetSymbol.IsGenericType
                                            ? $"<{Join(", ", targetSymbol.TypeParameters.Select(tp => tp.Name))}>"
                                            : "",
                                        targetSymbol.TypeParameters.Any()
                                            ? Join(
                                                "\r\n",
                                                targetSymbol.TypeParameters.Select(
                                                    tp => GenerateGenericTypeConstraints(tp)
                                                )
                                            )
                                            : ""
                                    )
                                )
                                .Replace(" override ", " ")
                                .Replace(" virtual ", " ")
                                .Replace("public ", "")
                                .Replace("!", ""),
                            @"\[(\w)",
                            "$1"
                        ),
                        @"(\w)\]",
                        "$1"
                    ),
                    @"\[(global.*\))\]",
                    "$1"
                )
            );
        }
    }

    private static string GenerateGenericTypeConstraints(ITypeParameterSymbol tp)
    {
        return
            tp.HasReferenceTypeConstraint
            || tp.HasValueTypeConstraint
            || tp.HasConstructorConstraint
            || tp.ConstraintTypes.Any()
            ? "where "
                + tp.Name
                + " : "
                + (tp.HasReferenceTypeConstraint ? "class" : "")
                + (tp.HasValueTypeConstraint ? "struct" : "")
                + Join(", ", tp.ConstraintTypes.Select(ct => ct.ToDisplayString()))
                + (tp.HasConstructorConstraint ? "new()" : "").Trim()
            : "";
    }
}
