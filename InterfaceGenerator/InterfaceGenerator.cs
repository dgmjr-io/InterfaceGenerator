using System.Diagnostics.SymbolStore;
//
// InterfaceGenerator.cs
//
//   Created: 2022-11-11-03:54:47
//   Modified: 2022-11-12-11:16:54
//
//   Author: David G. Mooore, Jr. <david@dgmjr.io>
//
//   Copyright Â© 2022-2023 David G. Mooore, Jr., All Rights Reserved
//      License: MIT (https://opensource.org/licenses/MIT)
//


namespace Dgmjr.InterfaceGenerator
{
    // using Dgmjr.ion.Extensions;
    using System.Collections.Immutable;
    using System.Linq;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using static System.String;

    [Generator]
    public partial class InterfaceGenerator : IIncrementalGenerator
    {
        /// <summary>
        /// Initializes the generator. This is called during generation and can be used to register source code that will be generated by the generator.
        /// </summary>
        /// <param name="context">Provides information about the compilation and environment that is passed to the generator</param>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValueProvider<
                ImmutableArray<(AttributeData?, INamedTypeSymbol?, SemanticModel SemanticModel)>
            > interfaces = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    GenerateInterfaceAttributeName,
                    (token, _) =>
                        token is InterfaceDeclarationSyntax interfaceDeclarationSyntax
                        && interfaceDeclarationSyntax.AttributeLists.Any(
                            al =>
                                al.Attributes.Any(
                                    a => a.AttributeClass?.Name == GenerateInterfaceAttributeName
                                )
                        ) ||
                        token is ClassDeclarationSyntax classDeclarationSyntax ||
                        token is StructDeclarationSyntax structDeclarationSyntax,
                    (context, _) =>
                        (
                            context.Attributes.FirstOrDefault(
                                a => a.AttributeClass?.Name == GenerateInterfaceAttributeName
                            ),
                            context.TargetSymbol as INamedTypeSymbol,
                            context.SemanticModel
                        )
                )
                .Collect();

            IncrementalValueProvider<Compilation> compilation = context.CompilationProvider;

            context.RegisterSourceOutput(interfaces, Generate);

            context.RegisterPostInitializationOutput(
                (ctx) =>
                    ctx.AddSource(
                        $"{GenerateInterfaceAttributeName}.g.cs",
                        GenerateInterfaceAtributeDeclaration
                    )
            );
        }

        /// <summary>
        /// Generates code for an attribute. This is the entry point for the generation of code for attributes that are derived from a type.
        /// </summary>
        /// <param name="context">The context in which to generate the code.</param>
        /// <param name="values">The values to generate for the attribute. This is an array of tuples where the first element is the attribute data the second element is the interface and the</param>
        protected static void Generate(
            SourceProductionContext context,
            ImmutableArray<(AttributeData?, INamedTypeSymbol?, SemanticModel)> values
        )
        {
            context.AddSource($"AttributeCount.g.cs", $"/* {values.Length} */");
            foreach (
                (
                    AttributeData? attributeData,
                    INamedTypeSymbol? targetSymbol,
                    SemanticModel semanticModel
                ) in values
            )
            {
                string interfaceName = targetSymbol.TypeKind == TypeKind.Interface ? targetSymbol.Name : "I" + targetSymbol.Name;
                string interfaceNamespace = targetSymbol.ContainingNamespace.ToDisplayString();
                INamedTypeSymbol? classToGenerateTheInterfaceFor =
                    attributeData.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol ?? targetSymbol as INamedTypeSymbol;
                context.AddSource(
                    interfaceName + ".g.cs",
                    InterfaceDeclarationTemplate.Render(
                        new InterfaceGeneratorModel(
                            interfaceNamespace,
                            interfaceName,
                            Join(
                                Environment.NewLine,
                                classToGenerateTheInterfaceFor
                                    .GetMembers()
                                    .Where(member => member.Kind is SymbolKind.Property)
                                    .OfType<IPropertySymbol>()
                                    .Where(p => p.DeclaredAccessibility == Accessibility.Public)
                                    .Select(
                                        p => p.ToDisplayString(Constants.SymbolDisplayFormat)
                                    // PropertyDeclarationTemplate.Render(
                                    //     new PropertyDeclarationModel(
                                    //         "public",
                                    //         p.Type.ToDisplayString(),
                                    //         p.Name,
                                    //         p.GetMethod != null,
                                    //         p.SetMethod != null,
                                    //         p.IsIndexer
                                    //             ? Join(
                                    //                 ", ",
                                    //                 p.Parameters.Select(
                                    //                     p =>
                                    //                         $"{p.Type.ToDisplayString()} {p.Name}"
                                    //                 )
                                    //             )
                                    //             : ""
                                    //     )
                                    // )
                                    )
                            )
                                + Environment.NewLine
                                + Join(
                                    Environment.NewLine,
                                    classToGenerateTheInterfaceFor
                                        .GetMembers()
                                        .Where(member => member.Kind is SymbolKind.Method)
                                        .OfType<IMethodSymbol>()
                                        .Where(
                                            m =>
                                                m.DeclaredAccessibility == Accessibility.Public
                                                && m.CanBeReferencedByName
                                        )
                                        .Select(
                                            m =>
                                                m.IsOverride
                                                    ? ""
                                                    : (
                                                        m.ToDisplayString(
                                                                Constants.SymbolDisplayFormat
                                                            )
                                                            .Replace("override", "") + ";"
                                                    )
                                        )
                                        .Where<string>(m => m.IndexOf("*") < 0)
                                ),
                            targetSymbol.IsGenericType
                                ? $"<{Join(", ", targetSymbol.TypeParameters.Select(tp => tp.Name))}>"
                                : "",
                            targetSymbol.TypeParameters.Any()
                                ? Join(
                                    "\r\n",
                                    targetSymbol.TypeParameters.Select(
                                        tp => GenerateGenericTypeConstraints(tp)
                                    )
                                )
                                : ""
                        )
                    )
                );
            }
        }

        private static string GenerateGenericTypeConstraints(ITypeParameterSymbol tp)
        {
            return
                tp.HasReferenceTypeConstraint
                || tp.HasValueTypeConstraint
                || tp.HasConstructorConstraint
                || tp.ConstraintTypes.Any()
                ? "where "
                    + tp.Name
                    + " : "
                    + (tp.HasReferenceTypeConstraint ? "class" : "")
                    + (tp.HasValueTypeConstraint ? "struct" : "")
                    + Join(", ", tp.ConstraintTypes.Select(ct => ct.ToDisplayString()))
                    + (tp.HasConstructorConstraint ? "new()" : "").Trim()
                : "";
        }
    }
}


//     public virtual void Generate(SourceProductionContext context, (Compilation Compilation, (AnalyzerConfigOptionsProvider AnalyzerConfigOptions, ImmutableArray<(InterfaceDeclarationSyntax, SemanticModel, ImmutableArray<AttributeData>)> Values) Values) values)
//     {
//         try
//         {
//             var (compilation, (analyzerConfigOptions, Values)) = values;
//             var interfaceAtributeDeclaration = GenerateInterfaceAtributeDeclaration;
//             var header = Header;
//             context.AddSource(GenerateInterfaceAttributeName + ".g.cs", interfaceAtributeDeclaration);
//             foreach(var (interfaceDeclaration, semanticModel, attributeData) in Values)
//             {
//                 var interfaceName = interfaceDeclaration.Identifier.Text;
//                 var interfaceNamespace = interfaceDeclaration.GetNamespace();
//                 var classToGenerateTheInterfaceFor = (Type)attributeData.First().ConstructorArguments.First().Value!;
//                 context.AddSource(interfaceName + "g.cs", $@"/* {header}
//     {classToGenerateTheInterfaceFor.Namespace}.{classToGenerateTheInterfaceFor.Name}
//     */");
//         }}
//         catch(Exception ex)
//         {
//             context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("INTERFACEGENERATOR", "Strongly Typed Resource Generator", ex.Message, "INTERFACEGENERATOR", DiagnosticSeverity.Error, true), Location.Create("StronglyTypesEmbeddedResourceGenerator.cs", new TextSpan(0, 0), new LinePositionSpan(new LinePosition(0, 0), new LinePosition(0, 0)))));
//             context.AddSource("Error.g.cs", $@"/* {ex.Source}: {ex.Message}:
// {ex.StackTrace} */");
//         }
//     }
