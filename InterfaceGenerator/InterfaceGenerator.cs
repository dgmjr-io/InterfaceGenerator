using System.Diagnostics.SymbolStore;

//
// InterfaceGenerator.cs
//
//   Created: 2022-11-11-03:54:47
//   Modified: 2022-11-12-11:16:54
//
//   Author: David G. Mooore, Jr. <david@dgmjr.io>
//
//   Copyright Â© 2022-2023 David G. Mooore, Jr., All Rights Reserved
//      License: MIT (https://opensource.org/licenses/MIT)
//


namespace Dgmjr.InterfaceGenerator
{
    using System.Collections.Immutable;
    using System.Linq;

    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    using static System.String;

    [Generator]
    public partial class InterfaceGenerator : IIncrementalGenerator
    {
        /// <summary>
        /// Initializes the generator. This is called during generation and can be used to register source code that will be generated by the generator.
        /// </summary>
        /// <param name="context">Provides information about the compilation and environment that is passed to the generator</param>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var interfaces = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    GenerateInterfaceAttributeName,
                    (token, _) =>
                        token
                            is InterfaceDeclarationSyntax
                                or ClassDeclarationSyntax
                                or StructDeclarationSyntax,
                    (context, _) =>
                        (
                            context.Attributes.FirstOrDefault(
                                a => a.AttributeClass?.Name is GenerateInterfaceAttributeName
                            ),
                            context.TargetSymbol as INamedTypeSymbol,
                            context.SemanticModel
                        )
                )
                .Collect();

            var compilation = context.CompilationProvider;

            context.RegisterSourceOutput(interfaces, Generate);

            // context.RegisterPostInitializationOutput(
            //     (ctx) =>
            //         ctx.AddSource(
            //             $"{GenerateInterfaceAttributeName}.g.cs",
            //             GenerateInterfaceAtributeDeclaration
            //         )
            // );
        }

        /// <summary>
        /// Generates code for an attribute. This is the entry point for the generation of code for attributes that are derived from a type.
        /// </summary>
        /// <param name="context">The context in which to generate the code.</param>
        /// <param name="values">The values to generate for the attribute. This is an array of tuples where the first element is the attribute data the second element is the interface and the</param>
        protected static void Generate(
            SourceProductionContext context,
            ImmutableArray<(AttributeData?, INamedTypeSymbol?, SemanticModel)> values
        )
        {
            context.AddSource("AttributeCount.g.cs", $"/* {values.Length} */");
            foreach ((var attributeData, var targetSymbol, var semanticModel) in values)
            {
                var interfaceName =
                    targetSymbol.TypeKind == TypeKind.Interface
                        ? targetSymbol.Name
                        : "I" + targetSymbol.Name;
                var interfaceNamespace = targetSymbol.ContainingNamespace.ToDisplayString();
                var classToGenerateTheInterfaceFor =
                    attributeData.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol
                    ?? targetSymbol;
                context.AddSource(
                    interfaceName + ".g.cs",
                    Regex.Replace(
                        Regex.Replace(
                            InterfaceDeclarationTemplate
                                .Render(
                                    new InterfaceGeneratorModel(
                                        interfaceNamespace,
                                        interfaceName,
                                        Join(
                                            Environment.NewLine,
                                            classToGenerateTheInterfaceFor
                                                .GetMembers()
                                                .Where(member => member.Kind is SymbolKind.Property)
                                                .OfType<IPropertySymbol>()
                                                .Where(
                                                    p =>
                                                        p.DeclaredAccessibility
                                                            == Accessibility.Public
                                                        && !p.IsStatic
                                                )
                                                .Select(
                                                    p =>
                                                        p.ToDisplayString(
                                                            Constants.SymbolDisplayFormat
                                                        )
                                                // PropertyDeclarationTemplate.Render(
                                                //     new PropertyDeclarationModel(
                                                //         "public",
                                                //         p.Type.ToDisplayString(),
                                                //         p.Name,
                                                //         p.GetMethod != null,
                                                //         p.SetMethod != null,
                                                //         p.IsIndexer
                                                //             ? Join(
                                                //                 ", ",
                                                //                 p.Parameters.Select(
                                                //                     p =>
                                                //                         $"{p.Type.ToDisplayString()} {p.Name}"
                                                //                 )
                                                //             )
                                                //             : ""
                                                //     )
                                                // )
                                                )
                                        )
                                            + Environment.NewLine
                                            + Join(
                                                Environment.NewLine,
                                                classToGenerateTheInterfaceFor
                                                    .GetMembers()
                                                    .Where(
                                                        member => member.Kind is SymbolKind.Method
                                                    )
                                                    .OfType<IMethodSymbol>()
                                                    .Where(
                                                        m =>
                                                            m.DeclaredAccessibility
                                                                == Accessibility.Public
                                                            && m.CanBeReferencedByName
                                                            && !m.IsStatic
                                                    )
                                                    .Select(
                                                        m =>
                                                            m.IsOverride
                                                                ? ""
                                                                : (
                                                                    m.ToDisplayString(
                                                                            Constants.SymbolDisplayFormat
                                                                        )
                                                                        .Replace("override", "")
                                                                    + ";"
                                                                )
                                                    )
                                                    .Where<string>(m => m.IndexOf("*") < 0)
                                            ),
                                        targetSymbol.IsGenericType
                                            ? $"<{Join(", ", targetSymbol.TypeParameters.Select(tp => tp.Name))}>"
                                            : "",
                                        targetSymbol.TypeParameters.Any()
                                            ? Join(
                                                "\r\n",
                                                targetSymbol.TypeParameters.Select(
                                                    tp => GenerateGenericTypeConstraints(tp)
                                                )
                                            )
                                            : ""
                                    )
                                )
                                .Replace(" override ", " ")
                                .Replace(" virtual ", " ")
                                .Replace("public ", "")
                                .Replace("!", ""),
                            @"\[(\w)",
                            "$1"
                        ),
                        @"(\w)\]",
                        "$1"
                    )
                );
            }
        }

        private static string GenerateGenericTypeConstraints(ITypeParameterSymbol tp)
        {
            return
                tp.HasReferenceTypeConstraint
                || tp.HasValueTypeConstraint
                || tp.HasConstructorConstraint
                || tp.ConstraintTypes.Any()
                ? "where "
                    + tp.Name
                    + " : "
                    + (tp.HasReferenceTypeConstraint ? "class" : "")
                    + (tp.HasValueTypeConstraint ? "struct" : "")
                    + Join(", ", tp.ConstraintTypes.Select(ct => ct.ToDisplayString()))
                    + (tp.HasConstructorConstraint ? "new()" : "").Trim()
                : "";
        }
    }
}
